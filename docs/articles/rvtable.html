<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Introduction to rvtable • rvtable</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">rvtable</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="..//index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/rvtable.html">Get Started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/leonawicz/rvtable">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Introduction to rvtable</h1>
                        <h4 class="author">Matthew Leonawicz</h4>
            
            <h4 class="date">2017-08-17</h4>
          </div>

    
    
<div class="contents">
<!-- rvtable.md is generated from rvtable.Rmd. Please edit that file -->
<p>The <code>rvtable</code> package provides a special type of data frame subclass with associated functionality for relatively convenient storage and manipulation of random variables. The emphasis is on distributions of continuous random variables derived from relatively large samples, though discrete random variables are also handled.</p>
<p>An rvtable contains a column defining values representing or sampled from a probability distribution and, usually (see below for exception), a column of respective probabilities. Additional columns are treated as ID columns and represent factors or categorical variables.</p>
<div id="motivation" class="section level1">
<h1 class="hasAnchor">
<a href="#motivation" class="anchor"></a>Motivation</h1>
<p>While this package can be used for organizing small samples, there is not much point. The main motivation for <code>rvtable</code> is relatively seamless storage and manipulation of empirically estimated continuous probability distributions deriving from relatively large samples or data sets.</p>
<p>By relatively large, I mean cases where it is both substantially more statistically and computationally efficient to store and subsequently work with estimated probability distributions that are derived from and sufficiently representative of the source data than to work directly on the source data itself.</p>
<p>For an example scenario, see the use case example further below in the vignette.</p>
<p>Note that it is of no benefit to known distributions with closed mathematical form expressions because there is never a need to lug a ton of such data around in the first place. For example, a random normal distribution can be sampled with <code>rnorm</code> at any time. <code>rvtable</code> is helpful for empirical samples which are large and messy, of a complicated form or mixed distributions, which cannot be reduced to a known or simple combination of known distributions, where an efficient snapshot of the distribution is helpful to avoid juggling excessive amounts of data from one analysis stage to the next while retaining sufficient distributional information.</p>
</div>
<div id="linking-code-and-concept" class="section level1">
<h1 class="hasAnchor">
<a href="#linking-code-and-concept" class="anchor"></a>Linking code and concept</h1>
<p>It is helpful to make the connection between operations performed by code and the probability concepts they parallel. The entirety of an rvtable as described above represents a joint probability distribution of the primary continuous or discrete random variable whose values and probabilities are represented by the values and probabilities columns and any categorical variables whose levels propagate any ID columns.</p>
<p>Filtering rows of an rvtable to specific combinations of ID variable levels yields a subset of the original table that represents a conditional distribution of the primary random variable. Similarly, integrating out, marginalizing over, or collapsing the table over the unique levels of one or multiple ID variables is analogous to calculating a marginal distribution of the primary random variable.</p>
</div>
<div id="package-functionality" class="section level1">
<h1 class="hasAnchor">
<a href="#package-functionality" class="anchor"></a>Package functionality</h1>
<p>This package offers a collection of functions that assist with manipulating tables of random variables in these and other ways. There is a constructor function, <code>rvtable</code>, for generating rvtables from different kinds of input data. An rvtable can be in probability distribution or sample form. This means that an rvtable will contain two columns, one of values and one of associated probabilities, when representing a distribution, but only the values column once sampled from. Form is tracked by object attributes.</p>
<p>Other functions available in the package offer seamless transitions between forms, carrying out various operations such as sampling (<code>sample_rvtable</code>) from densities and marginalizing over levels of categorical variables in an rvtable (<code>merge_rvtable</code> or <code>marginalize</code>). Users can maintain control over the resolution of the data via function arguments that correspond to any sampling or empirical density estimation steps that a function may perform. Probability mass functions can be computed and stored in a new rvtable (<code>inverse_pmf</code>) by inverting another rvtable, yielding the pmf of an ID variable conditional on a range of values of a continuous primary variable and any other ID variables.</p>
</div>
<div id="usage" class="section level1">
<h1 class="hasAnchor">
<a href="#usage" class="anchor"></a>Usage</h1>
<p>This introduction covers the following topics:</p>
<ul>
<li>Create various rvtable objects.</li>
<li>Sample from a distribution-type rvtable, yielding a new, sample-type rvtable.</li>
<li>Compute marginal distributions on an rvtable.</li>
<li>Compute an inverse empirical probability mass function from an rvtable.</li>
<li>Perform repeated cycles of distribution estimation and resampling.</li>
<li>Explore a toy example of a realistic use case.</li>
</ul>
<div id="creating-rvtable-objects" class="section level2">
<h2 class="hasAnchor">
<a href="#creating-rvtable-objects" class="anchor"></a>Creating rvtable objects</h2>
<p>There are several ways to create an rvtable from the constructor function, <code>rvtable</code>. Below are examples of continuous and discrete random variables stored in rvtables. In the first example, the input, <code>x</code>, is simply a numeric vector representing a sample. If <code>density.args</code> is not specified, the defaults are those used by <code>density</code>. See the help documentation for <code>density</code> for details. The second call below limits the sample from <code>n=512</code> to <code>n=50</code> and smooths the distribution by setting <code>adjust=2</code>. We can also check to see if an object has the <code>rvtable</code> class.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rvtable)
<span class="co"># basic samples from continuous and discrete RVs</span>
x &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">100</span>)
<span class="kw"><a href="../reference/rvtable.html">rvtable</a></span>(x)
<span class="kw"><a href="../reference/rvtable.html">rvtable</a></span>(x, <span class="dt">density.args =</span> <span class="kw">list</span>(<span class="dt">n =</span> <span class="dv">50</span>, <span class="dt">adjust =</span> <span class="dv">2</span>))
<span class="kw">is.rvtable</span>(<span class="kw"><a href="../reference/rvtable.html">rvtable</a></span>(x))</code></pre></div>
<p>This reveals that when working with “continuous” random variables, the distribution is always discretized to some degree. When high fidelity is required, increase <code>n</code>. This is increasingly important when working with a long data manipulation chain requiring many iterations of density estimation or sampling, such as marginalizing over multiple categorical variables or if it is critical to maintain the shape of a multimodal distribution with high precision.</p>
<p>The default is to assume <code>x</code> is continuous. In the next case, it is more ambiguous. While all values in this example are clearly discrete integers, they are still treated as samples from a continuous probability distribution and will be modeled internally by <code>density</code> as such unless <code>discrete=TRUE</code>.</p>
<p>For discrete random variables, probabilities associated with values of <code>x</code> can be passed to <code>y</code>. Alternatively, <code>x</code> can be passed without <code>y</code> for the same purpose if <code>x</code> has the attribute <code>probabilities</code>. Note that in either case, it is no longer necessary to explicitly pass <code>discrete=TRUE</code>. The discrete nature of <code>x</code> is inferred either from its attributes or from <code>y</code>. When <code>x</code> is a numeric vector, <code>discrete=TRUE</code> is only required when probabilities are not passed by <code>y</code> or by <code>x</code> attributes and <code>x</code> is a basic unweighted sample (but possibly with repeating values). At any time use <code>attributes</code> to inspect the attributes of an rvtable.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">size =</span> <span class="dv">10000</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>, <span class="dt">prob =</span> <span class="kw">sqrt</span>(<span class="dv">10</span><span class="op">:</span><span class="dv">1</span>))
<span class="kw"><a href="../reference/rvtable.html">rvtable</a></span>(x, <span class="dt">discrete =</span> <span class="ot">TRUE</span>)  <span class="co"># required</span>
x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span>
probs &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">0.15</span>, <span class="fl">0.25</span>)
<span class="kw"><a href="../reference/rvtable.html">rvtable</a></span>(x, <span class="dt">y =</span> probs)  <span class="co"># discreteness inferred from y</span>
<span class="kw">attr</span>(x, <span class="st">"probabilities"</span>) &lt;-<span class="st"> </span>probs
rv &lt;-<span class="st"> </span><span class="kw"><a href="../reference/rvtable.html">rvtable</a></span>(x)  <span class="co"># discreteness inferred from attributes</span>
rv
<span class="kw">attributes</span>(rv)</code></pre></div>
<p>Also note above that probabilities need not sum to one in the discrete case. They are relative weights and will be rescaled internally by <code>sample</code> rather than passed to <code>density</code> as is the case with continuous random variables.</p>
<p>Increasingly the complexity of the input to <code>rvtable</code>, we arrive at the more common ways to construct an rvtable: from and existing data frame. First is a data frame of values with equal probability.</p>
<p>Note that by leaving out <code>discrete=TRUE</code> in the call to <code>rvtable</code> below, as with a numeric input, <code>x</code>, the data frame input is also assumed to represent a continuous random variable sample. It will be estimated as if a tiny sample from a uniform pdf rather than a fully represented uniform pmf.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">Val =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">Prob =</span> <span class="fl">0.1</span>)
rv1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/rvtable.html">rvtable</a></span>(x)
rv1
<span class="kw">attributes</span>(rv1)
rv2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/rvtable.html">rvtable</a></span>(x, <span class="dt">discrete =</span> <span class="ot">TRUE</span>)
rv2
<span class="kw">attributes</span>(rv2)</code></pre></div>
<p>Lastly, we have the addition of an ID column, <code>id</code>, representing a categorical variable. The column names referring to values and their associated probabilities can also be changed.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">id =</span> <span class="kw">rep</span>(LETTERS[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>], <span class="dt">each =</span> <span class="dv">10</span>), <span class="dt">v1 =</span> <span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dv">2</span>), <span class="dt">p1 =</span> <span class="kw">c</span>(<span class="kw">c</span>(<span class="dv">10</span><span class="op">:</span><span class="dv">1</span>)<span class="op">^</span><span class="dv">2</span>, 
    <span class="kw">sqrt</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)))
rv &lt;-<span class="st"> </span><span class="kw"><a href="../reference/rvtable.html">rvtable</a></span>(x, <span class="dt">Val =</span> <span class="st">"v1"</span>, <span class="dt">Prob =</span> <span class="st">"p1"</span>)
rv
<span class="kw">attributes</span>(rv)</code></pre></div>
<p>Factors or ID columns like <code>id</code> above, if present, need not be <code>factor</code> in the literal <code>R</code> sense. They need not even be <code>character</code>, but they are columns in an rvtable that will be treated as some kind of discrete variable that can be meaningfully grouped by, for example.</p>
<p>The general assumption is that an rvtable is intended to have a column of values and a column of probabilities, which may describe a continuous or discrete random variable, and optionally some ID variables in other columns that essentially help to define conditional distributions.</p>
<p>In concluding, here are three important properties of <code>rvtable</code> worth being clear on:</p>
<ul>
<li><p>An rvtable can be created from a data frame that contains a values column but no corresponding probabilities column, analogous to when <code>x</code> is a basic numeric samples vector.</p></li>
<li><p><code>rvtable</code> always creates an rvtable in distribution form regardless of input, unless provided a basic sample with no probabilities and <code>force.dist=FALSE</code>.</p></li>
<li><p><code>rvtable</code> ignores grouping on purpose. See below.</p></li>
</ul>
<div id="a-note-of-caution-and-clarification" class="section level3">
<h3 class="hasAnchor">
<a href="#a-note-of-caution-and-clarification" class="anchor"></a>A note of caution and clarification</h3>
<p><em>Do not include other columns of continuous data or anything you do not want to use as an explicit ID variable</em> alongside the values and probabilities columns; rvtables and the functions that manipulate them work with <em>one</em> implicit random variable defined by <em>one</em> pair of values and probabilities columns. While ID columns add more variables to an rvtable, the focus remains on the main random variable. Any column in an rvtable not specified as a values or probabilities column will be treated as an ID variable. See bullet point below.</p>
<p>This is the initial stopgap to using rvtables as not intended. If you pass a data frame whose rows have been grouped by any categorical variables using <code><a href="http://dplyr.tidyverse.org/reference/group_by.html">dplyr::group_by</a></code>, this grouping information is ignored, but will be passed through. <code>rvtable</code> forcibly groups by all categorical variables present in the input, regardless; this means all columns present that are not one of the two values or probabilities columns.</p>
<p>Subsequent functions honor grouping information, but the assumption and intent here is that any data provided to <code>rvtable</code> to initially construct and rvtable object is relevant, either the key variable or an important ID variable. Furthermore, it is reasonable to assume that any present ID variables are already distinguishing different sets of values and probabilities in a table and it is not intended for the <code>rvtable</code> constructor to also apply any marginalizing operations if it is passed a data frame that has no or only partial grouping.</p>
<p><code>rvtable</code> always separates all apparent combinations of ID variables’ levels and groups by all of them. When returning an rvtable object, it will reassign any grouping that might have been part of the input rather than strip grouping or retain full grouping.</p>
</div>
</div>
<div id="sampling-rvtables" class="section level2">
<h2 class="hasAnchor">
<a href="#sampling-rvtables" class="anchor"></a>Sampling rvtables</h2>
<p>Sampling on an rvtable requires a density-type rvtable. This is the more common form. Sampling results in a new rvtable object that is of sampling-type, meaning its <code>Val</code> column represents raw sample values and there is no corresponding <code>Prob</code> column of probabilities tied to values. This is the less common rvtable type and tends to be explicitly created and used at the end of a chain of data manipulation steps when it finally comes time to do something with the data such as plot it or pass samples to an analysis.</p>
<p>Sampling is done using <code>sample_rvtable</code>. Below, small samples are drawn from rvtables containing continuous and discrete random variables, respectively.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># continuous RV</span>
x &lt;-<span class="st"> </span><span class="kw"><a href="../reference/rvtable.html">rvtable</a></span>(<span class="kw">rnorm</span>(<span class="dv">1000</span>))
x
<span class="kw">attributes</span>(x)<span class="op">$</span>tabletype
y &lt;-<span class="st"> </span><span class="kw"><a href="../reference/sample_rvtable.html">sample_rvtable</a></span>(x, <span class="dt">n =</span> <span class="dv">10</span>)
y
<span class="kw">attributes</span>(y)<span class="op">$</span>tabletype

<span class="co"># discrete RV</span>
x &lt;-<span class="st"> </span><span class="kw"><a href="../reference/rvtable.html">rvtable</a></span>(<span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">100</span>, <span class="dv">50</span>), <span class="dt">discrete =</span> <span class="ot">TRUE</span>)
y &lt;-<span class="st"> </span><span class="kw"><a href="../reference/sample_rvtable.html">sample_rvtable</a></span>(x, <span class="dt">n =</span> <span class="dv">10</span>)
<span class="kw"><a href="../reference/sample_rvtable.html">sample_rvtable</a></span>(y, <span class="dt">n =</span> <span class="dv">8</span>, <span class="dt">resample =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>In the above example, the <code>tabletype</code> entry in the attributes of <code>y</code> is different from that in <code>x</code>. After sampling from the density-type rvtable, the resultant rvtable is in sample form. In the discrete example, <code>sample_rvtable</code> is called on an rvtable that is already in sample form. In this case samples are taken directly from the rvtable <code>Val</code> column unless <code>resample=TRUE</code>, which forces the additional step of re-estimation of the pmf or pdf prior to resampling. This is especially useful in the continuous case when the user requires more control over the sampling distribution via <code>density.args</code> prior to resampling.</p>
<p>Returning to the data frame from earlier, sampling is performed by group.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">id =</span> <span class="kw">rep</span>(LETTERS[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>], <span class="dt">each =</span> <span class="dv">10</span>), <span class="dt">v1 =</span> <span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dv">2</span>), <span class="dt">p1 =</span> <span class="kw">c</span>(<span class="kw">c</span>(<span class="dv">10</span><span class="op">:</span><span class="dv">1</span>)<span class="op">^</span><span class="dv">2</span>, 
    <span class="kw">sqrt</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)))
rv &lt;-<span class="st"> </span><span class="kw"><a href="../reference/rvtable.html">rvtable</a></span>(x, <span class="dt">Val =</span> <span class="st">"v1"</span>, <span class="dt">Prob =</span> <span class="st">"p1"</span>)
<span class="kw"><a href="../reference/sample_rvtable.html">sample_rvtable</a></span>(rv, <span class="dt">n =</span> <span class="dv">5</span>)</code></pre></div>
<p>Aside from <code>x</code>, other arguments to <code>sample_rvtable</code> include:</p>
<ul>
<li>
<code>resample</code> as described.</li>
<li>
<code>n</code>, the sample size.</li>
</ul>
<p>The sample size defaults to 10,000 because the typical context for the <code>rvtable</code> package is empirical estimation of continuous probability distributions with high-fidelity/flexibility. While sampling comes after density estimation, it is also helpful to retain larger samples if densities are subsequently re-estimated.</p>
<ul>
<li>
<code>interp</code>, which defaults to <code>TRUE</code>, applies linear interpolation between samples prior to sampling.</li>
<li>
<code>n.interp</code>, the sample size resulting from <code>interp=TRUE</code>, defaults to 100,000.</li>
<li>
<code>decimals</code> is available for rounding samples.</li>
<li>
<code>density.args</code> takes a list of arguments to pass to <code>density</code> to override defaults, just as in <code>rvtable</code>.</li>
</ul>
<p>Like the constructor, <code>rvtable</code>, <code>sample_rvtable</code> also forcibly applies its sampling to each identifiable group and does not acknowledge any existing grouping information that has been added to a data frame. The function will not presume that the user intends to implicitly marginalize over other ID variables; computing marginal distributions is intended always to be performed explicitly. For one thing, ID variables might stem from weighted samples of random variables and the user must be aware of instances where it would be incorrect to automatically merge two ID variables with accounting for this. For singling out or collapsing over ID variables, we turn to the next section.</p>
</div>
<div id="computing-marginal-distributions-on-rvtables" class="section level2">
<h2 class="hasAnchor">
<a href="#computing-marginal-distributions-on-rvtables" class="anchor"></a>Computing marginal distributions on rvtables</h2>
<p>There is not much to say about conditional distributions because this is relatively trivial. A conditional distribution of the random variable described by <code>Val</code> and <code>Prob</code> given, say, an ID variable being equal to one or some subset of some of its levels, is obtained by simply subsetting the rvtable to those rows.</p>
<p>On the other hand, marginalizing over levels of an ID variable to yield a marginal distribution of the random variable described by <code>Val</code> and <code>Prob</code>, is more complex. This is done with <code>marginalize</code>, which is a wrapper around <code>merge_rvtable</code>. While the latter is exported by the <code>rvtable</code> package and can make sense to use directly, it is typical to use <code>marginalize</code>, specifically.</p>
<p>Below, <code>marginalize</code> is used to collapse an rvtable by integrating out or marginalizing over categorical variables. The <code>margin</code> argument describes which variables to marginalize over. In the first example, <code>marginalize</code> collapses the rvtable over the levels of <code>id1</code> and <code>id2</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">id1 =</span> <span class="kw">rep</span>(LETTERS[<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>], <span class="dt">each =</span> <span class="dv">4</span>), <span class="dt">id2 =</span> <span class="kw">factor</span>(<span class="kw">c</span>(<span class="st">"low"</span>, <span class="st">"high"</span>)), 
    <span class="dt">id3 =</span> <span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="dt">each =</span> <span class="dv">2</span>), <span class="dt">Val =</span> <span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">each =</span> <span class="dv">20</span>), <span class="dt">Prob =</span> <span class="kw">rep</span>(<span class="kw">sqrt</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>), 
        <span class="dt">each =</span> <span class="dv">20</span>))
rv &lt;-<span class="st"> </span><span class="kw"><a href="../reference/rvtable.html">rvtable</a></span>(x)
<span class="kw"><a href="../reference/marginalize.html">marginalize</a></span>(rv, <span class="dt">margin =</span> <span class="kw">c</span>(<span class="st">"id1"</span>, <span class="st">"id2"</span>))</code></pre></div>
<p><code>get_levels</code> can be used to quickly check the unique levels of an ID variable. Note that ID columns do not have to be of class <code>factor</code> to be treated as ID/categorical/factor variables, etc. Character vectors suffice.</p>
<p>A reason this is helpful is because when marginalizing over an ID variable, it is possible to pass a vector of weights or probabilities when integration should account for weighted samples. For example, an rvtable may have equal numbers of rows describing the probability distribution of a continuous random variable conditional on each of two ID variable levels. However, it may be known by the user that each of these levels do not contribute equally to the marginal distribution. Weights must be passed in the same orders as the levels returned by <code>get_levels</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/get_levels.html">get_levels</a></span>(rv, <span class="st">"id1"</span>)
<span class="kw"><a href="../reference/marginalize.html">marginalize</a></span>(rv, <span class="st">"id1"</span>, <span class="dt">weights =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="fl">1.5</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>))</code></pre></div>
<p>When weights need to be specified, <code>marginalize</code> can only collapse over one ID variable at a time. If multiple variables must be integrated out, this can usually be done with a single call as shown, but when weights are supplied, then <code>marginalize</code> must be called successively. The current implementation of <code>marginalize</code> does not allow <code>weights</code> to take a list of weights vectors for each of multiple ID variables.</p>
</div>
<div id="computing-an-inverse-pmf" class="section level2">
<h2 class="hasAnchor">
<a href="#computing-an-inverse-pmf" class="anchor"></a>Computing an inverse pmf</h2>
<p>An inverse pmf can be computed using <code>inverse_pmf</code>. Continuing with the previous rvtable, we obtain the pdf of <code>id1</code> conditioned on a range of values of the continuous random variable described by the original rvtable as well as the other present factors. The values column is now categorical and takes on the levels associated with <code>id1</code> in the input.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/inverse_pmf.html">inverse_pmf</a></span>(rv, <span class="dt">val.range =</span> <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">8</span>), <span class="st">"id1"</span>)
y1

<span class="kw">library</span>(dplyr)
x2 &lt;-<span class="st"> </span><span class="kw">filter</span>(rv, id2 <span class="op">==</span><span class="st"> "low"</span> <span class="op">&amp;</span><span class="st"> </span>id3 <span class="op">==</span><span class="st"> </span><span class="dv">1</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">select</span>(<span class="op">-</span>id2, <span class="op">-</span>id3) <span class="op">%&gt;%</span><span class="st"> </span>rvtable
y2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/inverse_pmf.html">inverse_pmf</a></span>(x2, <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">8</span>), <span class="st">"id1"</span>)
y2</code></pre></div>
<p>The difference between the two calls to <code>inverse_pmf</code> above is that in the second call, the rvtable has first been subset to one combination of levels of <code>id2</code> and <code>id3</code>. In both cases, the pmf of <code>id1</code> is conditional on values of <code>id2</code>, <code>id3</code> and the continuous random variable represented by values and probabilities in the original rvtable; it is merely not including all levels of <code>id2</code> and <code>id3</code> in the second example.</p>
<p>Here is another, highly simplified example where the primary variable is now discrete and, like the single additional ID variable, has only two unique values:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x2 &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">id1 =</span> <span class="kw">c</span>(<span class="st">"A"</span>, <span class="st">"B"</span>), <span class="dt">Val =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>), <span class="dt">Prob =</span> <span class="kw">c</span>(<span class="fl">0.25</span>, <span class="fl">0.5</span>, 
    <span class="fl">0.75</span>, <span class="fl">0.5</span>)) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw"><a href="../reference/rvtable.html">rvtable</a></span>(<span class="dt">discrete =</span> <span class="ot">TRUE</span>)
<span class="kw"><a href="../reference/inverse_pmf.html">inverse_pmf</a></span>(x2, <span class="dv">1</span>, <span class="st">"id1"</span>)
<span class="kw"><a href="../reference/inverse_pmf.html">inverse_pmf</a></span>(x2, <span class="dv">2</span>, <span class="st">"id1"</span>)
<span class="kw"><a href="../reference/inverse_pmf.html">inverse_pmf</a></span>(x2, <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="st">"id1"</span>)</code></pre></div>
<p>For more information about the <code>rvtable</code> package, see the <a href="http://leonawicz.github.io/rvtable/">help documentation</a></p>
</div>
<div id="density-re-estimation-and-resampling" class="section level2">
<h2 class="hasAnchor">
<a href="#density-re-estimation-and-resampling" class="anchor"></a>Density re-estimation and resampling</h2>
<p>It is important to be aware of the level of possible signal degradation that can occur with some combination of:</p>
<ul>
<li>the density resolution being too low, leading to a more discretized density.</li>
<li>the bandwidth being too high, leading to a more highly smoothed, less flexible density.</li>
<li>the number of times that a density is sampled from and the size of the sample</li>
<li>the number of times a density is re-estimated from a sample, such as happens when computing marginal distributions, which requires sampling from multiple densities, combining weighted or unweighted samples, and estimating a density from the pooled sample.</li>
</ul>
<p>In general, the fewer cycles of sampling and density estimation the better. However, if is not difficult to force retention of the original density estimation within acceptable tolerances for an analysis if the sampling size is large enough and the density estimation is fine-grained and flexible enough. The important thing is that what is “enough” is always something that should be directly assessed. What is enough will be different for different types of data and random variables as well as varying suitability for different purposes.</p>
<p>In the examples below, the same data sample is used with different combinations of parameters for density estimation and sampling. A number of resampling and re-estimation cycles are repeated in each case and signal degradation is plotted for select iterations. In typical use cases, re-estimation is restricted to just a few times; examples where there is a reason to perform this kind of cycling many more times are difficult to envision. Nonetheless, the number of iterations used here is relatively extreme.</p>
</div>
<div id="use-case-example" class="section level2">
<h2 class="hasAnchor">
<a href="#use-case-example" class="anchor"></a>Use case example</h2>
<p>As an example, say we have a large collection of high resolution maps that each contain many millions of pixels. The entire set may contain billions or even trillions of pixels, not to mention that the degree of spatial autocorrelation is so extreme that from the outset we know that for many purposes the data set, while containing much data, contains relatively little information.</p>
<p>Various statistical analyses that may need to be performed with data may not require anywhere near this amount or resolution of data. There is much room for data reduction and the key is striking the right balance for the data and the type of analysis. However, merely accessing it all to get started can be a computational challenge, one that is ideally revisited as seldom as possible for subsequent analyses. It is much easier to revisit a smaller, derived data set that is still statistically sufficient for the analysis at hand.</p>
<p>At one extreme, someone with a programming background but no knowledge of probability and statistics might take a brute force approach, attempting, often in vain and not without wasting vast amounts of time, to use every pixel even if their goal is to simply calculate the mean all pixels when using a tiny sample would do just as well. When asked later for the standard deviation, they will repeat the brute force attack on the massive data set and obtain the next value.</p>
<p>At the other extreme, rather than applying judicious sampling and efficient data reduction methodologies, one might simply reduce everything in one go to statistics such as the mean and standard deviation. But like the previous instance, something new and unanticipated is often required later. Reducing all the data down to a set of statistics can preclude all kinds of analyses, requiring the analyst to revisit the burden of accessing the massive source data yet again, all the while wishing they could have foreseen the need last time for whatever they are accessing it for this time around.</p>
<p><code>rvtable</code> bridges this gap for many use cases like this, where the happy medium, the Goldilocks zone, is to model and store empirical estimates of probability distributions from high resolution source data or massive sample or population data. Downstream analyses can depend on such a derived data set, not needing to go to the source to be able to compute arbitrary statistics from full distributional information, nor being hamstrung by overly aggregated data.</p>
<p>Specifically, imagine using the R function, <code>density</code>, to empirically estimate the continuous probability distribution of a set of observations. It returns a list with <code>x</code> and <code>y</code> vectors that together describe the estimated density curve. If signal fidelity is of paramount importance and any further data aggregation should be postponed until later in an analysis pipeline, one can model a higher resolution estimated density with greater flexibility by increasing the number of points and/or decreasing the bandwidth. Whereas doing so might necessitate a <code>x</code> and <code>y</code> vectors containing 1,000 values each and there might be 1,000 of these for 1,000 different data sets, resulting in carrying 2 million total values through the bulk of a processing chain and steps of an analysis, these estimated density curves could capture all the information needed from source data sets that are far larger.</p>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#motivation">Motivation</a></li>
      <li><a href="#linking-code-and-concept">Linking code and concept</a></li>
      <li><a href="#package-functionality">Package functionality</a></li>
      <li>
<a href="#usage">Usage</a><ul class="nav nav-pills nav-stacked">
<li><a href="#creating-rvtable-objects">Creating rvtable objects</a></li>
      <li><a href="#sampling-rvtables">Sampling rvtables</a></li>
      <li><a href="#computing-marginal-distributions-on-rvtables">Computing marginal distributions on rvtables</a></li>
      <li><a href="#computing-an-inverse-pmf">Computing an inverse pmf</a></li>
      <li><a href="#density-re-estimation-and-resampling">Density re-estimation and resampling</a></li>
      <li><a href="#use-case-example">Use case example</a></li>
      </ul>
</li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Matthew Leonawicz.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
